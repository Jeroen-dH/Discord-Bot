"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stdlib_1 = __importDefault(require("@doctormckay/stdlib"));
const http_1 = require("@doctormckay/stdlib/http");
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const https_1 = __importDefault(require("https"));
const socks_proxy_agent_1 = require("socks-proxy-agent");
const steamid_1 = __importDefault(require("steamid"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const AuthenticationClient_1 = __importDefault(require("./AuthenticationClient"));
const helpers_1 = require("./helpers");
const WebApiTransport_1 = __importDefault(require("./transports/WebApiTransport"));
const WebSocketCMTransport_1 = __importDefault(require("./transports/WebSocketCMTransport"));
const EAuthSessionGuardType_1 = __importDefault(require("./enums-steam/EAuthSessionGuardType"));
const EAuthTokenPlatformType_1 = __importDefault(require("./enums-steam/EAuthTokenPlatformType"));
const EResult_1 = __importDefault(require("./enums-steam/EResult"));
const ESessionPersistence_1 = __importDefault(require("./enums-steam/ESessionPersistence"));
const debug = (0, debug_1.default)('steam-session:LoginSession');
/**
 * Using CommonJS:
 * ```js
 * const {LoginSession} = require('steam-session');
 * ```
 *
 * Using ES6 modules:
 * ```js
 * import {LoginSession} from 'steam-session';
 * ```
 *
 * The {@link LoginSession} class is the primary way to interact with steam-session.
 *
 * @see Example: [login-with-password.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-password.ts)
 * @see Example: [login-with-qr.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-qr.ts)
 */
class LoginSession extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * @param {EAuthTokenPlatformType} platformType - A value from {@link EAuthTokenPlatformType}.
     * You should set this to the appropriate platform type for your desired usage.
     * @param {ConstructorOptions} [options]
     * @return
     *
     * Constructs a new `LoginSession` instance. Example usage:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * ```
     */
    constructor(platformType, options) {
        super();
        options = options || {};
        let agent = new https_1.default.Agent({ keepAlive: true });
        if (options.httpProxy && options.socksProxy) {
            throw new Error('Cannot specify both httpProxy and socksProxy at the same time');
        }
        if (options.httpProxy) {
            agent = stdlib_1.default.HTTP.getProxyAgent(true, options.httpProxy);
        }
        else if (options.socksProxy) {
            agent = new socks_proxy_agent_1.SocksProxyAgent(options.socksProxy);
        }
        this._webClient = new http_1.HttpClient({ httpsAgent: agent });
        this._platformType = platformType;
        let transport = options.transport;
        if (!transport) {
            switch (platformType) {
                case EAuthTokenPlatformType_1.default.SteamClient:
                    transport = new WebSocketCMTransport_1.default(this._webClient, agent);
                    break;
                default:
                    transport = new WebApiTransport_1.default(this._webClient);
            }
        }
        this._handler = new AuthenticationClient_1.default(this._platformType, transport, this._webClient);
        this._handler.on('debug', (...args) => this.emit('debug-handler', ...args));
        this.on('debug', debug);
        this.loginTimeout = 30000;
    }
    /**
     * A `number` specifying the time, in milliseconds, before a login attempt will {@link timeout}. The timer begins
     * after {@link polling} begins.
     *
     * If you attempt to set this property after {@link polling} has already been emitted, an Error will be thrown since
     * setting this property after that point has no effect.
     */
    get loginTimeout() {
        return this._loginTimeout;
    }
    set loginTimeout(value) {
        if (this._pollingStartedTime) {
            throw new Error('Setting loginTimeout after polling has already started is ineffective');
        }
        this._loginTimeout = value;
    }
    /**
     * **Read-only.** A [`SteamID`](https://www.npmjs.com/package/steamid) instance containing the SteamID for the
     * currently-authenticated account. Populated immediately after {@link startWithCredentials}
     * resolves, or immediately after {@link accessToken} or {@link refreshToken} are set (meaning that
     * this is always populated when {@link authenticated} fires).
     */
    get steamID() {
        // There's a few places we could get a steamid from
        if (this._startSessionResponse && this._startSessionResponse.steamId) {
            return new steamid_1.default(this._startSessionResponse.steamId);
        }
        else if (this.accessToken || this.refreshToken) {
            let token = this.accessToken || this.refreshToken;
            let decodedToken = (0, helpers_1.decodeJwt)(token);
            return new steamid_1.default(decodedToken.sub);
        }
        else {
            return null;
        }
    }
    /**
     * **Read-only.** A `string` containing your account name. This is populated just before the {@link authenticated}
     * event is fired.
     */
    get accountName() { return this._accountName; }
    /**
     * A `string` containing your access token. This is populated just before the {@link authenticated} event is fired.
     * You can also assign an access token to this property if you already have one, although at present that wouldn't
     * do anything useful.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to a refresh token rather than an access token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link refreshToken} and you set this to a token that doesn't belong to the same account as the refresh token
     *
     * Access tokens can't be used for much. You can use them with a few undocumented WebAPIs like
     * [IFriendsListService/GetFriendsList](https://steamapi.xpaw.me/#IFriendsListService/GetFriendsList) by passing the access
     * token as an access_token query string parameter. For example:
     *
     *     https://api.steampowered.com/IFriendsListService/GetFriendsList/v1/?access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * As of time of writing (2023-04-24), it appears that you can also use access tokens with regular published API methods,
     * for example:
     *
     *     https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid=440&access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * node-steamcommunity also has a method you can use to provide it with an access token:
     * [`setMobileAppAccessToken`](https://github.com/DoctorMcKay/node-steamcommunity/wiki/SteamCommunity#setmobileappaccesstokenaccesstoken)
     */
    get accessToken() { return this._accessToken; }
    set accessToken(token) {
        if (!token) {
            this._accessToken = token;
            return;
        }
        let decoded = (0, helpers_1.decodeJwt)(token);
        try {
            new steamid_1.default(decoded.sub);
        }
        catch {
            throw new Error('Not a valid Steam token');
        }
        let aud = decoded.aud || [];
        if (aud.includes('derive')) {
            throw new Error('The provided token is a refresh token, not an access token');
        }
        if (this._startSessionResponse
            && this._startSessionResponse.steamId
            && decoded.sub != this._startSessionResponse.steamId) {
            throw new Error('Token is for a different account. To work with a different account, create a new LoginSession.');
        }
        if (this._refreshToken) {
            let decodedRefreshToken = (0, helpers_1.decodeJwt)(this._refreshToken);
            if (decodedRefreshToken.sub != decoded.sub) {
                throw new Error('This access token belongs to a different account from the set refresh token.');
            }
        }
        // Everything checks out
        this._accessToken = token;
    }
    /**
     * A `string` containing your refresh token. This is populated just before the {@link authenticated} event is fired.
     * You can also assign a refresh token to this property if you already have one.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to an access token rather than a refresh token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link accessToken} and you set this to a token that doesn't belong to the same account as the access token
     */
    get refreshToken() { return this._refreshToken; }
    set refreshToken(token) {
        if (!token) {
            this._refreshToken = token;
            return;
        }
        let decoded = (0, helpers_1.decodeJwt)(token);
        try {
            new steamid_1.default(decoded.sub);
        }
        catch {
            throw new Error('Not a valid Steam token');
        }
        let aud = decoded.aud || [];
        if (!aud.includes('derive')) {
            throw new Error('The provided token is an access token, not a refresh token');
        }
        let requiredAudience = 'unknown';
        switch (this._platformType) {
            case EAuthTokenPlatformType_1.default.SteamClient:
                requiredAudience = 'client';
                break;
            case EAuthTokenPlatformType_1.default.MobileApp:
                requiredAudience = 'mobile';
                break;
            case EAuthTokenPlatformType_1.default.WebBrowser:
                requiredAudience = 'web';
                break;
        }
        if (!aud.includes(requiredAudience)) {
            throw new Error(`Token platform type is different from the platform type of this LoginSession instance (required audience "${requiredAudience}" but got "${aud.join(',')}"`);
        }
        if (this._startSessionResponse
            && this._startSessionResponse.steamId
            && decoded.sub != this._startSessionResponse.steamId) {
            throw new Error('Token is for a different account. To work with a different account, create a new LoginSession.');
        }
        if (this._accessToken) {
            let decodedAccessToken = (0, helpers_1.decodeJwt)(this._accessToken);
            if (decodedAccessToken.sub != decoded.sub) {
                throw new Error('This refresh token belongs to a different account from the set access token.');
            }
        }
        // Everything checks out
        this._refreshToken = token;
    }
    /**
     * **Read-only.** A `string` containing your Steam Guard machine token. This is populated when you pass a `steamGuardMachineToken` to
     * {@link startWithCredentials}, or just before the {@link steamGuardMachineToken} event is emitted.
     */
    get steamGuardMachineToken() { return this._steamGuardMachineToken; }
    get _defaultWebsiteId() {
        switch (this._platformType) {
            case EAuthTokenPlatformType_1.default.SteamClient:
                return 'Client';
            case EAuthTokenPlatformType_1.default.WebBrowser:
                return 'Community';
            case EAuthTokenPlatformType_1.default.MobileApp:
                return 'Mobile';
            default:
                return 'Community';
        }
    }
    _verifyStarted(mustHaveSteamId = false) {
        if (!this._startSessionResponse) {
            throw new Error('Login session has not been started yet');
        }
        if (this._pollingCanceled) {
            throw new Error('Login attempt has been canceled');
        }
        if (mustHaveSteamId && !this.steamID) {
            throw new Error('Cannot use this method with this login scheme');
        }
    }
    /**
     * @param details
     * @return
     *
     * Starts a new login attempt using your account credentials. Returns a Promise.
     *
     * If you're logging in with {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}, you
     * can supply a Buffer containing the SHA-1 hash of your sentry file for
     * {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}.
     *
     * For example:
     *
     *
     * ```js
     * import {createHash} from 'crypto';
     * import {readFileSync} from 'fs';
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let hash = createHash('sha1');
     * hash.update(readFileSync('ssfn1234567890'));
     * let buffer = hash.digest(); // buffer contains a Buffer
     *
     * let session = new LoginSession(EAuthTokenPlatformType.SteamClient);
     * session.startWithCredentials({
     *     accountName: 'johndoe',
     *     password: 'h3ll0wor1d',
     *     steamGuardMachineToken: buffer
     * });
     * ```
     *
     * If you supply a {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} here and you're using email-based
     * Steam Guard, Steam will send you a new Steam Guard email if you're using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}
     * or {@link EAuthTokenPlatformType.MobileApp}. You would ideally keep your LoginSession active that generated your
     * first email, and pass the code using {@link submitSteamGuardCode} instead of creating a new LoginSession and
     * supplying the code to {@link startWithCredentials}.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: InvalidPassword
     *   eresult: 5
     * ```
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * Here's a list of which guard types might be present in this method's response, and how you should proceed:
     *
     * - {@link EAuthSessionGuardType.EmailCode}: An email was sent to you containing a code
     *   (`detail` contains your email address' domain, e.g. `gmail.com`).
     *   You should get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession}
     *   and supply that code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling
     *   {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceCode}: You need to supply a TOTP code from your mobile authenticator
     *   (or by using [steam-totp](https://www.npmjs.com/package/steam-totp)).
     *   Get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession} and supply that
     *   code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceConfirmation}: You need to approve the confirmation prompt in your Steam
     *   mobile app. If this guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     * - {@link EAuthSessionGuardType.EmailConfirmation}: You need to approve the confirmation email sent to you. If this
     *   guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     *
     * Note that multiple guard types might be available; for example both {@link EAuthSessionGuardType.DeviceCode} and
     * {@link EAuthSessionGuardType.DeviceConfirmation} can be available at the same time.
     *
     * When this method resolves, {@link steamID} will be populated.
     */
    async startWithCredentials(details) {
        if (this._startSessionResponse) {
            throw new Error('A session has already been started on this LoginSession object. Create a new LoginSession to start a new session.');
        }
        this._hadRemoteInteraction = false;
        this._steamGuardCode = details.steamGuardCode;
        if (typeof details.steamGuardMachineToken == 'string') {
            this._steamGuardMachineToken = details.steamGuardMachineToken;
        }
        let encryptionResult = await this._handler.encryptPassword(details.accountName, details.password);
        this._startSessionResponse = await this._handler.startSessionWithCredentials({
            accountName: details.accountName,
            ...encryptionResult,
            persistence: details.persistence || ESessionPersistence_1.default.Persistent,
            platformType: this._platformType,
            // use a manually-specified token with priority over a token saved on this object
            steamGuardMachineToken: details.steamGuardMachineToken || this.steamGuardMachineToken
        });
        this.emit('debug', 'start session response', this._startSessionResponse);
        return await this._processStartSessionResponse();
    }
    /**
     * @return
     *
     * Starts a new QR login attempt. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. Realistically, failures should never happen unless Steam is having problems or you're having network issues.
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * {@link steamID} will not be populated when this method resolves, since at this point we don't know which account
     * we're going to log into. It will be populated after you successfully {@link authenticated | authenticate}.
     *
     * Immediately after this resolves, {@link LoginSession} will start {@link polling} to determine when authentication
     * has succeeded.
     */
    async startWithQR() {
        if (this._startSessionResponse) {
            throw new Error('A session has already been started on this LoginSession object. Create a new LoginSession to start a new session.');
        }
        this._hadRemoteInteraction = false;
        this._startSessionResponse = await this._handler.startSessionWithQR({
            platformType: this._platformType
        });
        this.emit('debug', 'start qr session response', this._startSessionResponse);
        return await this._processStartSessionResponse();
    }
    async _processStartSessionResponse() {
        this._pollingCanceled = false;
        let validActions = [];
        for (let i of this._startSessionResponse.allowedConfirmations) {
            switch (i.type) {
                case EAuthSessionGuardType_1.default.None:
                    this.emit('debug', 'no guard required');
                    // Use setImmediate here so that the promise is resolved before we potentially emit a session
                    setImmediate(() => this._doPoll());
                    return { actionRequired: false };
                case EAuthSessionGuardType_1.default.EmailCode:
                case EAuthSessionGuardType_1.default.DeviceCode:
                    let codeType = i.type == EAuthSessionGuardType_1.default.EmailCode ? 'email' : 'device';
                    this.emit('debug', `${codeType} code required`);
                    let authResult = await (codeType == 'email' ? this._attemptEmailCodeAuth() : this._attemptTotpCodeAuth());
                    if (authResult) {
                        // We successfully authed already, no action needed
                        return { actionRequired: false };
                    }
                    else {
                        // We need a code from the user
                        let action = { type: i.type };
                        if (i.message) {
                            action.detail = i.message;
                        }
                        validActions.push(action);
                        break;
                    }
                case EAuthSessionGuardType_1.default.DeviceConfirmation:
                case EAuthSessionGuardType_1.default.EmailConfirmation:
                    this.emit('debug', 'device or email confirmation guard required');
                    validActions.push({ type: i.type });
                    setImmediate(() => this._doPoll());
                    break;
                case EAuthSessionGuardType_1.default.MachineToken:
                    // Do nothing here since this is handled by _attemptEmailCodeAuth
                    break;
                default:
                    let guardTypeString = i.type.toString();
                    for (let j in EAuthSessionGuardType_1.default) {
                        if (EAuthSessionGuardType_1.default[j] == guardTypeString) {
                            guardTypeString = j;
                            break;
                        }
                    }
                    throw new Error(`Unknown auth session guard type ${guardTypeString}`);
            }
        }
        // If we got here but we have no valid actions, something went wrong
        if (validActions.length == 0) {
            throw new Error('Login requires action, but we can\'t tell what kind of action is required');
        }
        let response = {
            actionRequired: true,
            validActions
        };
        if (this._startSessionResponse.challengeUrl) {
            let startSessionResponse = this._startSessionResponse;
            response.qrChallengeUrl = startSessionResponse.challengeUrl;
        }
        return response;
    }
    /**
     * @return
     *
     * Forces an immediate polling attempt. This will throw an `Error` if you call it before the {@link polling} event is
     * emitted, after {@link authenticated} is emitted, or after you call {@link cancelLoginAttempt}.
     */
    forcePoll() {
        this._verifyStarted();
        if (!this._pollingStartedTime) {
            throw new Error('Polling has not yet started');
        }
        this._doPoll();
    }
    async _doPoll() {
        if (this._pollingCanceled) {
            return;
        }
        // If we called _doPoll outside of an existing timer, cancel the timer
        clearTimeout(this._pollTimer);
        if (!this._pollingStartedTime) {
            this._pollingStartedTime = Date.now();
            this.emit('polling');
        }
        let totalPollingTime = Date.now() - this._pollingStartedTime;
        if (totalPollingTime >= this.loginTimeout) {
            this.emit('timeout');
            this.cancelLoginAttempt();
            return;
        }
        let pollResponse;
        try {
            pollResponse = await this._handler.pollLoginStatus(this._startSessionResponse);
            this.emit('debug', 'poll response', pollResponse);
        }
        catch (ex) {
            // If we got an error, but we've already canceled polling, just do nothing.
            if (!this._pollingCanceled) {
                this.emit('error', ex);
                this.cancelLoginAttempt();
            }
            return;
        }
        this._startSessionResponse.clientId = pollResponse.newClientId || this._startSessionResponse.clientId;
        if (pollResponse.hadRemoteInteraction && !this._hadRemoteInteraction) {
            this._hadRemoteInteraction = true;
            this.emit('remoteInteraction');
        }
        if (pollResponse.newSteamGuardMachineAuth) {
            this._steamGuardMachineToken = pollResponse.newSteamGuardMachineAuth;
            this.emit('steamGuardMachineToken');
        }
        if (pollResponse.accessToken) {
            this._accountName = pollResponse.accountName;
            this.accessToken = pollResponse.accessToken;
            this.refreshToken = pollResponse.refreshToken;
            this.emit('authenticated');
            this.cancelLoginAttempt();
        }
        else if (!this._pollingCanceled) {
            this._pollTimer = setTimeout(() => this._doPoll(), this._startSessionResponse.pollInterval * 1000);
        }
    }
    /**
     * @returns {boolean} - true if code submitted successfully, false if code wasn't valid or no code available
     */
    async _attemptEmailCodeAuth() {
        if (this._steamGuardCode) {
            try {
                await this.submitSteamGuardCode(this._steamGuardCode);
                return true;
            }
            catch (ex) {
                if (ex.eresult != EResult_1.default.InvalidLoginAuthCode) {
                    // this is some kind of important error
                    throw ex;
                }
            }
        }
        // Can we use a machine auth token?
        if (this._platformType == EAuthTokenPlatformType_1.default.WebBrowser
            && this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.MachineToken)) {
            let result = await this._handler.checkMachineAuthOrSendCodeEmail({
                machineAuthToken: this.steamGuardMachineToken,
                ...this._startSessionResponse
            });
            this.emit('debug', `machine auth check response: ${EResult_1.default[result.result]}`);
            if (result.result == EResult_1.default.OK) {
                // Machine auth succeeded
                setImmediate(() => this._doPoll());
                return true;
            }
        }
        // An email was sent
        return false;
    }
    async _attemptTotpCodeAuth() {
        if (this._steamGuardCode) {
            try {
                await this.submitSteamGuardCode(this._steamGuardCode);
                return true; // submitting code succeeded
            }
            catch (ex) {
                if (ex.eresult != EResult_1.default.TwoFactorCodeMismatch) {
                    // this is some kind of important error
                    throw ex;
                }
            }
        }
        // If we got here, then we need the user to supply a code
        return false;
    }
    /**
     * @param authCode - Your Steam Guard code
     * @return
     *
     * If a Steam Guard code is needed, you can supply it using this method. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: TwoFactorCodeMismatch
     *   eresult: 88
     * ```
     *
     * Note that an incorrect email code will fail with EResult value {@link EResult.InvalidLoginAuthCode} (65), and an
     * incorrect TOTP code will fail with EResult value {@link EResult.TwoFactorCodeMismatch} (88).
     *
     * On success, the Promise will be resolved with no value. In this case, you should expect for {@link authenticated}
     * to be emitted shortly.
     */
    async submitSteamGuardCode(authCode) {
        this._verifyStarted(true);
        this.emit('debug', 'submitting steam guard code', authCode);
        let needsEmailCode = this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.EmailCode);
        let needsTotpCode = this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.DeviceCode);
        if (!needsEmailCode && !needsTotpCode) {
            throw new Error('No Steam Guard code is needed for this login attempt');
        }
        await this._handler.submitSteamGuardCode({
            ...this._startSessionResponse,
            authCode,
            authCodeType: needsEmailCode ? EAuthSessionGuardType_1.default.EmailCode : EAuthSessionGuardType_1.default.DeviceCode
        });
        setImmediate(() => this._doPoll());
    }
    /**
     * @return - True if we were actively polling and it has now been canceled. False if we were not polling.
     *
     * Cancels {@link polling} for an ongoing login attempt. Once canceled, you should no longer interact with this
     * {@link LoginSession} object, and you should create a new one if you want to start a new attempt.
     */
    cancelLoginAttempt() {
        this._pollingCanceled = true;
        this._handler.close();
        if (this._pollTimer) {
            clearTimeout(this._pollTimer);
            return true;
        }
        return false;
    }
    /**
     * @return
     *
     * Once successfully {@link authenticated}, you can call this method to get cookies for use on the Steam websites.
     * You can also manually set {@link refreshToken} and then call this method without going through another login
     * attempt if you already have a valid refresh token. Returns a Promise.
     *
     * On failure, the Promise will be rejected. Depending on the nature of the failure, an {@link EResult} may or may
     * not be available.
     *
     * On success, the Promise will be resolved with an array of strings. Each string contains a cookie, e.g.
     * `'steamLoginSecure=blahblahblahblah'`.
     *
     * Here's an example of how you can get new web cookies when you already have a valid refresh token:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * let cookies = await session.getWebCookies();
     * ```
     */
    async getWebCookies() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get web cookies');
        }
        let sessionId = (0, crypto_1.randomBytes)(12).toString('hex');
        // If our platform type is MobileApp or SteamClient, then our access token *is* our session cookie.
        // The same is likely true for WebBrowser, but we want to mimic official behavior as closely as possible to avoid
        // any potential future breakage.
        if ([EAuthTokenPlatformType_1.default.SteamClient, EAuthTokenPlatformType_1.default.MobileApp].includes(this._platformType)) {
            if (!this.accessToken) {
                await this.refreshAccessToken();
            }
            let cookieValue = encodeURIComponent([this.steamID.getSteamID64(), this.accessToken].join('||'));
            return [`steamLoginSecure=${cookieValue}`, `sessionid=${sessionId}`];
        }
        let body = {
            nonce: this.refreshToken,
            sessionid: sessionId,
            redir: 'https://steamcommunity.com/login/home/?goto='
        };
        debug('POST https://login.steampowered.com/jwt/finalizelogin %o', body);
        let finalizeResponse = await this._webClient.request({
            method: 'POST',
            url: 'https://login.steampowered.com/jwt/finalizelogin',
            headers: helpers_1.API_HEADERS,
            multipartForm: http_1.HttpClient.simpleObjectToMultipartForm(body)
        });
        if (finalizeResponse.jsonBody && finalizeResponse.jsonBody.error) {
            throw (0, helpers_1.eresultError)(finalizeResponse.jsonBody.error);
        }
        if (!finalizeResponse.jsonBody || !finalizeResponse.jsonBody.transfer_info) {
            let err = new Error('Malformed login response');
            err.responseBody = finalizeResponse.jsonBody;
            throw err;
        }
        // Now we want to execute all transfers specified in the finalizelogin response. Technically we only need one
        // successful transfer (hence the usage of promsieAny), but we execute them all for robustness in case one fails.
        // As long as one succeeds, we're good.
        let transfers = finalizeResponse.jsonBody.transfer_info.map(({ url, params }) => new Promise(async (resolve, reject) => {
            let body = { steamID: this.steamID.getSteamID64(), ...params };
            debug('POST %s %o', url, body);
            let result;
            try {
                result = await this._webClient.request({
                    method: 'POST',
                    url,
                    multipartForm: http_1.HttpClient.simpleObjectToMultipartForm(body)
                });
            }
            catch (error) {
                return reject(error);
            }
            if (!result.headers || !result.headers['set-cookie'] || result.headers['set-cookie'].length == 0) {
                return reject(new Error('No Set-Cookie header in result'));
            }
            if (!result.headers['set-cookie'].some(c => c.startsWith('steamLoginSecure='))) {
                return reject(new Error('No steamLoginSecure cookie in result'));
            }
            resolve(result.headers['set-cookie'].map(c => c.split(';')[0].trim()));
        }));
        let cookies = await promiseAny(transfers);
        if (!cookies.some((c) => c.includes('sessionid'))) {
            cookies.push(`sessionid=${sessionId}`);
        }
        return cookies;
    }
    /**
     * @return
     *
     * As long as a {@link refreshToken} is set, you can call this method to obtain a new access token.
     * Returns a Promise.
     *
     * On failure, the Promise will be rejected. An {@link EResult} will be available under the `eresult` property of
     * the Error object.
     *
     * On success, the Promise will be resolved with no value. You can then read the access token from the LoginSession's
     * {@link accessToken} property.
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * await session.refreshAccessToken();
     *
     * console.log(`New access token: ${session.accessToken}`);
     * ```
     *
     * As of 2023-04-24, this method works for {@link EAuthTokenPlatformType.MobileApp | EAuthTokenPlatformType.MobileApp}
     * and {@link EAuthTokenPlatformType.SteamClient}, but using {@link EAuthTokenPlatformType.WebBrowser} will fail
     * with response {@link EResult.AccessDenied}.
     */
    async refreshAccessToken() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get a new access token');
        }
        this.accessToken = (await this._handler.generateAccessTokenForApp(this.refreshToken)).accessToken;
    }
    /**
     * @return boolean
     *
     * Does the same thing as {@link refreshAccessToken}, while also attempting to renew your refresh token.
     *
     * Whether a new refresh token will actually be issued is at the discretion of the Steam backend. This method will
     * return true if a new refresh token was issued (which can be accessed using the {@link refreshToken} property), or
     * false if no new refresh token was issued. Regardless of the return value, the {@link accessToken} property is
     * always updated with a fresh access token (unless there was an error).
     *
     * **Important:** If a refresh token is successfully renewed (e.g. this method returns true), the old refresh token
     * will become invalid, even if it is not yet expired.
     */
    async renewRefreshToken() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get a new access token');
        }
        let { accessToken, refreshToken } = await this._handler.generateAccessTokenForApp(this.refreshToken, true);
        this.accessToken = accessToken;
        this.refreshToken = refreshToken || this.refreshToken;
        return !!refreshToken;
    }
}
exports.default = LoginSession;
////////////////////////////
// DOCS FOR EVENTS FOLLOW //
////////////////////////////
/**
 * This event is emitted once we start polling Steam to periodically check if the login attempt has succeeded or not.
 * Polling starts when any of these conditions are met:
 *
 * - A login session is successfully started with credentials and no guard is required (e.g. Steam Guard is disabled)*
 * - A login session is successfully started with credentials and you supplied a valid code to {@link StartLoginSessionWithCredentialsDetails.steamGuardCode}*
 * - A login session is successfully started with credentials, you're using email Steam Guard, and you supplied a valid {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}*
 * - A login session is successfully started with credentials, then you supplied a valid code to {@link submitSteamGuardCode}*
 * - A login session is successfully started, and {@link EAuthSessionGuardType.DeviceConfirmation} or {@link EAuthSessionGuardType.EmailConfirmation} are among the valid guards
 * 	 - This case covers {@link startWithQR | QR logins}, since a QR login is a device confirmation under the hood
 *
 * \* = in these cases, we expect to only have to poll once before login succeeds.
 *
 * After this event is emitted, if your {@link loginTimeout} elapses and the login attempt has not yet succeeded,
 * {@link timeout} is emitted and the login attempt is abandoned. You would then need to start a new login attempt
 * using a fresh {@link LoginSession} object.
 *
 * @event
 */
LoginSession.polling = 'polling';
/**
 * This event is emitted when the time specified by {@link loginTimeout} elapses after {@link polling} begins, and
 * the login attempt has not yet succeeded. When `timeout` is emitted, {@link cancelLoginAttempt} is called internally.
 *
 * @event
 */
LoginSession.timeout = 'timeout';
/**
 * This event is emitted when Steam reports a "remote interaction" via {@link polling}. This is observed to happen
 * when the approval prompt is viewed in the Steam mobile app for the {@link EAuthSessionGuardType.DeviceConfirmation}
 * guard. For a {@link startWithQR | QR login}, this would be after you scan the code, but before you tap approve or deny.
 *
 * @event
 */
LoginSession.remoteInteraction = 'remoteInteraction';
/**
 * This event is emitted when Steam sends us a new Steam Guard machine token. Machine tokens are only relevant when logging
 * into an account that has email-based Steam Guard enabled. Thus, this will only be emitted after successfully logging into
 * such an account.
 *
 * At this time, this event is only emitted when logging in using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}.
 * It's not presently possible to get a machine token for the {@link EAuthTokenPlatformType.WebBrowser} platform
 * (and {@link EAuthTokenPlatformType.MobileApp} platform doesn't support machine tokens at all).
 *
 * When this event is emitted, the {@link LoginSession#steamGuardMachineToken} property contains your new machine token.
 *
 * @event
 */
LoginSession.steamGuardMachineToken = 'steamGuardMachineToken';
/**
 * This event is emitted when we successfully authenticate with Steam. At this point, {@link accountName},
 * {@link accessToken}, and {@link refreshToken} are populated. If the {@link EAuthTokenPlatformType}
 * passed to the {@link constructor} is appropriate, you can now safely call {@link getWebCookies}.
 *
 * @event
 */
LoginSession.authenticated = 'authenticated';
/**
 * This event is emitted if we encounter an error while {@link polling}. The first argument to the event handler is
 * an Error object. If this happens, the login attempt has failed and will need to be retried.
 *
 * Node.js will crash if this event is emitted and not handled.
 *
 * ```js
 * session.on('error', (err) => {
 *     console.error(`An error occurred: ${err.message}`);
 * });
 * ```
 *
 * @event
 */
LoginSession.error = 'error';
/**
 * @param {Promise[]} promises
 * @returns {Promise}
 */
function promiseAny(promises) {
    // for node <15 compat
    return new Promise((resolve, reject) => {
        let pendingPromises = promises.length;
        let rejections = [];
        promises.forEach((promise) => {
            promise.then((result) => {
                pendingPromises--;
                resolve(result);
            }).catch((err) => {
                pendingPromises--;
                rejections.push(err);
                if (pendingPromises == 0) {
                    reject(rejections[0]);
                }
            });
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9naW5TZXNzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0xvZ2luU2Vzc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlFQUF5QztBQUN6QyxtREFBa0U7QUFDbEUsbUNBQW1DO0FBQ25DLGtEQUFnQztBQUNoQyxrREFBMEI7QUFDMUIseURBQWtEO0FBQ2xELHNEQUE4QjtBQUM5QiwyREFBZ0Q7QUFFaEQsa0ZBQTBEO0FBQzFELHVDQUErRDtBQUUvRCxtRkFBMkQ7QUFDM0QsNkZBQXFFO0FBY3JFLGdHQUF3RTtBQUN4RSxrR0FBMEU7QUFDMUUsb0VBQTRDO0FBQzVDLDRGQUFvRTtBQUVwRSxNQUFNLEtBQUssR0FBRyxJQUFBLGVBQVcsRUFBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBbUJ4RDs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxNQUFxQixZQUFhLFNBQVEsaUNBQWdDO0lBb0J6RTs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFBWSxZQUFvQyxFQUFFLE9BQTRCO1FBQzdFLEtBQUssRUFBRSxDQUFDO1FBRVIsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7UUFFeEIsSUFBSSxLQUFLLEdBQWUsSUFBSSxlQUFLLENBQUMsS0FBSyxDQUFDLEVBQUMsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7UUFDM0QsSUFBSSxPQUFPLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDNUMsTUFBTSxJQUFJLEtBQUssQ0FBQywrREFBK0QsQ0FBQyxDQUFDO1NBQ2pGO1FBRUQsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3RCLEtBQUssR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQWdCLENBQUM7U0FDMUU7YUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDOUIsS0FBSyxHQUFHLElBQUksbUNBQWUsQ0FB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